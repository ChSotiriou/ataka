import os
import time
import typer
import functools
import subprocess
import multiprocessing

from typing import List
from player_cli.cmd_exploit import app, _get_histories
from player_cli.ctfconfig_wrapper import OWN_HOST, RUNLOCAL_TARGETS
from player_cli.util import (
    request, dt_from_iso, dt_to_local_str, highlight_flags,
    magentify, blueify, greenify, yellowfy, redify,
    ERROR_STR, WARN_STR
)


_EXECUTION_STATUS_IS_FINAL = set([
    'finished', 'failed', 'timeout', 'cancelled'
])

_EXECUTION_STATUS_COLOR = {
    'running': blueify,
    'finished': greenify,
    'failed': redify,
    'timeout': yellowfy,
}


def _print_output(label, output):
    if not output:
        return
    for line in output.splitlines():
        typer.echo(f'{label} {line}')


def _print_exploit_execution(job, execution, target):
    exe_desc = f'execution {execution["id"]} of job {job["id"]}'

    status = execution['status']
    status_color = _EXECUTION_STATUS_COLOR.get(status, magentify)
    status_note = ' (not finished, check back later)' if status not in _EXECUTION_STATUS_IS_FINAL else ''

    typer.echo(f'--- Begin {exe_desc} ---')
    typer.echo(f'Status    : {status_color(status)}{status_note}')
    typer.echo(f'Exploit   : {job["exploit_id"]}')
    typer.echo(f'Target    : {target["ip"]} ({target["service"]})')
    typer.echo(f'Timestamp : {dt_to_local_str(job["timestamp"])}')

    if execution['stdout'] is not None:
        stdout = highlight_flags(execution['stdout'], blueify)
        _print_output('   ', stdout)
    if execution['stderr'] is not None:
        stderr = highlight_flags(execution['stderr'], blueify)
        _print_output(redify('ERR'), stderr)

    typer.echo(f'--- End {exe_desc} ---')
    typer.echo()


@app.command('logs', help='Show remote exploit logs.')
def exploit_logs(
    cmd_ids: List[str] = typer.Argument(..., metavar='EXPLOIT_ID...', help=
        'Exploit ID or history ID. '
        'If an exploit ID is specified, shows logs for that exploit. '
        'If a history ID is specified, shows logs for the active exploits in the history. '
        'You can specify multiple IDs and mix exploit and history IDs.'),
    limit: int = typer.Option(1, '-n', '--num', metavar='NUM', help=
        'Show logs for the last NUM ticks.')
):
    histories = _get_histories()
    all_exploit_ids = set(x['id'] for h in histories.values() for x in h['exploits'])

    exploit_ids = set()

    for cur_id in cmd_ids:
        if cur_id in histories:
            found = False
            for exploit in histories[cur_id]['exploits']:
                if exploit['active']:
                    exploit_ids.add(exploit['id'])
                    found = True
            if not found:
                typer.echo(f'{WARN_STR}: no active exploit in history "{cur_id}"')
        else:
            if cur_id not in all_exploit_ids:
                typer.echo(f'{ERROR_STR}: exploit "{cur_id}" does not exist')
                raise typer.Exit(code=1)
            exploit_ids.add(cur_id)

    exploit_ids = list(sorted(exploit_ids))

    typer.echo(f'Showing logs for exploits: {", ".join(exploit_ids)}')
    typer.echo()

    job_items = []
    for exploit_id in exploit_ids:
        exploit_items = request('GET', f'exploit/{exploit_id}/jobs', params={
            'limit': limit,
        })
        for item in exploit_items:
            item['job']['timestamp'] = dt_from_iso(item['job']['timestamp'])
        job_items += exploit_items

    job_items.sort(key=lambda x: x['job']['timestamp'])

    for item in job_items:
        job = item['job']
        for execution, target in zip(item['executions'], item['targets']):
            _print_exploit_execution(job, execution, target)
