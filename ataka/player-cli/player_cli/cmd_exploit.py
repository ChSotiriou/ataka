import io
import os
import sys
import time

import typer
import base64
import tarfile

import player_cli.cmd_exploit_target
from player_cli.ctfconfig_wrapper import RUNLOCAL_TARGETS

from typing import List
from player_cli.cmd_service import service_ls
from player_cli.cmd_exploit_target import _print_exploit_targets
from player_cli.util import (
    request, check_response, dt_from_iso, dt_to_local_str, highlight_flags,
    magentify, blueify, greenify, yellowfy, redify,
    WARN_STR, ERROR_STR, NOTICE_STR
)

app = typer.Typer()

app.add_typer(player_cli.cmd_exploit_target.app,
              name='target', help='Manage exploit targets.')

ACTIVE_STR = greenify('ACTIVE')

EXECUTION_STATUS_IS_FINAL = {'finished', 'failed', 'timeout', 'cancelled'}

EXECUTION_STATUS_COLOR = {
    'running': blueify,
    'finished': greenify,
    'failed': redify,
    'timeout': yellowfy,
}

def _status_colored(status):
    return EXECUTION_STATUS_COLOR.get(status, magentify)(status)


def _print_output(label, output):
    if not output:
        return
    for line in output.splitlines():
        typer.echo(f'{label} {line}')


def _print_exploit_execution(job, execution):
    exe_desc = f'execution {execution["id"]} of job {job["id"]}'

    status = execution['status']
    status_note = ' (not finished, check back later)' if status not in EXECUTION_STATUS_IS_FINAL else ''

    typer.echo(f'--- Begin {exe_desc} ---')
    typer.echo(f'Status    : {_status_colored(status)}{status_note}')
    typer.echo(f'Exploit   : {job["exploit_id"]}')
    typer.echo(f'Target    : {execution["target"]["ip"]} ({execution["target"]["service"]})')
    typer.echo(f'Timestamp : {dt_to_local_str(job["timestamp"])}')

    if execution['stdout'] is not None:
        stdout = highlight_flags(execution['stdout'], blueify)
        _print_output('   ', stdout)
    if execution['stderr'] is not None:
        stderr = highlight_flags(execution['stderr'], blueify)
        _print_output(redify('ERR'), stderr)

    typer.echo(f'--- End {exe_desc} ---')
    typer.echo()


def _get_histories():
    histories = request('GET', 'exploit_history')
    exploits = request('GET', 'exploit')

    result = {}
    for history in histories:
        hist_exploits = [
            exploit for exploit in exploits
            if exploit['exploit_history_id'] == history['id']
        ]
        for exploit in hist_exploits:
            exploit['timestamp'] = dt_from_iso(exploit['timestamp'])
        hist_exploits.sort(key=lambda x: x['timestamp'])

        result[history['id']] = {
            'id': history['id'],
            'service': history['service'],
            'exploits': hist_exploits,
        }

    return result


@app.command('ls', help='List all exploits.')
def exploit_ls(
        history_ids: List[str] = typer.Argument(None, help='History ID(s).')
):
    history_ids = set(history_ids)

    histories = _get_histories()

    for history_id, history_info in histories.items():
        if history_ids and history_id not in history_ids:
            continue

        typer.echo(f'{history_id} ({history_info["service"]})')

        has_active = False
        exploits = history_info['exploits']
        if not exploits:
            typer.echo('    No uploaded exploits yet')
        else:
            for exploit in exploits:
                if exploit['active']:
                    has_active = True

                active = ACTIVE_STR if exploit['active'] else ''
                ts = dt_to_local_str(exploit['timestamp'])
                typer.echo(f'    {ts} {active:6} {exploit["author"]} {exploit["id"]}')

        if has_active:
            typer.echo('')
            _print_exploit_targets(history_info, indent=4)

        typer.echo('')


@app.command('activate', help='Activate an exploit.')
def exploit_activate(
        exploit_id: str = typer.Argument(..., help=
        'Exploit ID or history ID. '
        'If an exploit ID is specified, activates that exploit. '
        'If a history ID is specified, activates the most recent exploit in '
        'the history if none is already activated.')
):
    resp = request('PATCH', f'exploit/{exploit_id}', data={
        'active': True
    })

    if not resp.get('success', True) and resp.get('error', '') == 'Exploit does not exist':
        histories = _get_histories()

        history = histories.get(exploit_id)
        if history is None:
            typer.echo(f'{ERROR_STR}: unknown exploit or history "{exploit_id}"')
            raise typer.Exit(code=1)

        if not history['exploits']:
            typer.echo(f'{ERROR_STR}: no exploits in history "{exploit_id}"')
            raise typer.Exit(code=1)

        if any(exploit['active'] for exploit in history['exploits']):
            typer.echo(f'{WARN_STR}: an exploit is already active, doing nothing')
            return

        exploit_id = history['exploits'][-1]['id']
        typer.echo(f'Activate {exploit_id}')
        resp = request('PATCH', f'exploit/{exploit_id}', data={
            'active': True
        })

    check_response(resp)


@app.command('deactivate', help='Deactivate an exploit.')
def exploit_deactivate(
        exploit_id: str = typer.Argument(..., help=
        'Exploit ID or history ID. '
        'If an exploit ID is specified, deactivates that exploit. '
        'If a history ID is specified, deactivates all exploits in the history.')
):
    resp = request('PATCH', f'exploit/{exploit_id}', data={
        'active': False,
    })

    if not resp.get('success', True) and resp.get('error', '') == 'Exploit does not exist':
        histories = _get_histories()

        history = histories.get(exploit_id)
        if history is None:
            typer.echo(f'{ERROR_STR}: unknown exploit or history "{exploit_id}"')
            raise typer.Exit(code=1)

        for exploit in history['exploits']:
            if exploit['active']:
                exploit_id = exploit['id']
                typer.echo(f'Deactivate {exploit_id}')
                check_response(request('PATCH', f'exploit/{exploit_id}', data={
                    'active': False
                }))
    else:
        check_response(resp)


@app.command('switch', help=
'Activate an exploit and deactivate all others in the history.')
def exploit_switch(
        exploit_id: str = typer.Argument(..., help='Exploit ID.')
):
    exploits = request('GET', 'exploit')

    history_id = None
    for exploit in exploits:
        if exploit['id'] == exploit_id:
            history_id = exploit['exploit_history_id']
            break
    if history_id is None:
        typer.echo(f'{ERROR_STR}: unknown exploit "{exploit_id}"')
        raise typer.Exit(code=1)

    already_active = False
    for exploit in exploits:
        if exploit['exploit_history_id'] != history_id:
            continue
        if exploit['active']:
            if exploit['id'] == exploit_id:
                already_active = True
                continue
            typer.echo(f'Deactivate {exploit["id"]}')
            exploit_deactivate(exploit['id'])

    if not already_active:
        typer.echo(f'Activate {exploit_id}')
        exploit_activate(exploit_id)


@app.command('create', help='Create an exploit history.')
def exploit_create(
        history_id: str = typer.Argument(..., help='History ID (the "friendly" exploit name).'),
        service: str = typer.Argument(..., help='The target service.')
):
    resp = request('POST', 'exploit_history', data={
        'history_id': history_id,
        'service': service,
    })

    if not resp.get('success', True) and resp.get('error', '') == 'Unknown service':
        typer.echo(f'ERROR: unknown service "{service}", available services:')
        service_ls()
        raise typer.Exit(code=1)

    check_response(resp)


@app.command('upload', help='Upload an exploit.')
def exploit_upload(
        history_id: str = typer.Argument(..., help='History ID (the "friendly" exploit name).'),
        author: str = typer.Argument(..., help='The author.'),
        context: str = typer.Argument(..., help=
        'Path to a directory or tarball containing the Docker context. '
        'The Dockerfile must be top-level. '
        'Supported tarball compression formats: xz, bzip2, gzip, identity (no compression).'),
        y: bool = typer.Option(False, help='Switch to new exploit after uploading.'),
):
    if os.path.isdir(context):
        with io.BytesIO() as bio:
            with tarfile.open(fileobj=bio, mode='w:gz') as tar:
                tar.add(context, arcname='')
            bio.seek(0)
            context_data = bio.read()
    else:
        with open(context, 'rb') as f:
            context_data = f.read()

    resp = request('POST', 'exploit', data={
        'history_id': history_id,
        'author': author,
        'context': base64.b64encode(context_data).decode(),
    })
    check_response(resp)

    exploit_id = resp['exploit_id']
    job_id = resp['job_id']
    typer.echo(f"{exploit_id}: Waiting for initial job {job_id} to finish..", nl=False)
    job_status = None

    for i in range(20):
        resp = request('GET', f'jobs/{job_id}')
        check_response(resp)
        job = resp['job']
        executions = resp['executions']
        typer.echo(f".", nl=False)
        if job_status != job['status']:
            typer.echo(f" {_status_colored(job['status'])}", nl=False)
        job_status = job['status']

        if job['status'] in EXECUTION_STATUS_IS_FINAL:
            job['timestamp'] = dt_from_iso(job['timestamp'])
            typer.echo("\n")
            for e in executions:
                _print_exploit_execution(job, e)
            break

        time.sleep(1)

    if job_status == 'finished':
        if not y:
            msg = f"{NOTICE_STR} Do you want to activate the newly uploaded exploit {exploit_id}?"
            histories = _get_histories()
            history = histories[history_id]
            if len(previous_versions := [exploit['id'] for exploit in history['exploits'] if exploit['active']]) > 0:
                msg += f"\n{NOTICE_STR} this would deactivate the previous version: {','.join(previous_versions)}"
            else:
                msg += f"\n{NOTICE_STR} this is a fresh exploit"
            should_switch = typer.confirm(msg)
        else:
            should_switch = True

        if should_switch:
            exploit_switch(exploit_id)
        else:
            typer.echo(f"{WARN_STR}: Did not activate exploit {exploit_id}.")

    elif job_status == 'failed':
        typer.echo(f"{ERROR_STR}: Job execution failed, not switching exploit automatically.")
        typer.echo(f"Please fix the issue and re-run the upload")
    else:
        typer.echo(f"{WARN_STR}: Job did not finish within 20 seconds, not switching exploit over automatically.")
        typer.echo(f"Check results manually with `{sys.argv[0]} exploit logs {exploit_id}`")
        typer.echo(f"Afterwards use `{sys.argv[0]} exploit switch {exploit_id}` to switch over central execution")


@app.command('download', help='Download an exploit.')
def exploit_download(
        exploit_id: str = typer.Argument(..., help='Exploit ID.'),
        path: str = typer.Argument(..., help='Output directory (will be created).'),
        overwrite: bool = typer.Option(False, '--overwrite', help=
        'Proceed even if the destination directory already exists.'),
        unsafe: bool = typer.Option(False, '--unsafe', help=
        'DANGEROUS: do not perform safety checks before extracting the downloaded archive.')
):
    resp = request('GET', f'exploit/{exploit_id}/download')
    check_response(resp)

    data = base64.b64decode(resp['data'])

    with io.BytesIO(data) as bio:
        with tarfile.open(fileobj=bio) as tar:
            if not unsafe:
                for info in tar:
                    if info.name.startswith('/'):
                        typer.echo(f'{ERROR_STR}: unsafe archive: absolute path detected')
                        raise typer.Exit(code=1)
                    elif '/../' in f'/{info.name}/':
                        typer.echo(f'{ERROR_STR}: unsafe archive: path traversal detected')
                        raise typer.Exit(code=1)
                    elif info.islnk() or info.issym():
                        typer.echo(f'{ERROR_STR}: unsafe archive: link detected')
                        raise typer.Exit(code=1)

            try:
                os.mkdir(path)
            except FileExistsError:
                if overwrite:
                    typer.echo(f'{WARN_STR}: directory "{path}" already exists (proceeding anyway)')
                else:
                    typer.echo(f'{ERROR_STR}: directory "{path}" already exists (use --overwrite to proceed anyway)')
                    raise typer.Exit(code=1)

            tar.extractall(path)


import player_cli.cmd_exploit_logs
import player_cli.cmd_exploit_runlocal
import player_cli.cmd_exploit_template
