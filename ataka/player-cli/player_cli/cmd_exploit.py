import io
import os
import typer
import base64
import tarfile

import player_cli.cmd_exploit_target

from typing import List
from player_cli.cmd_service import service_ls
from player_cli.cmd_exploit_target import _print_exploit_targets
from player_cli.util import (
    request, check_response, dt_from_iso, dt_to_local_str, blueify, greenify,
    WARN_STR, ERROR_STR, NOTICE_STR
)


app = typer.Typer()

app.add_typer(player_cli.cmd_exploit_target.app,
              name='target', help='Manage exploit targets.')


ACTIVE_STR = greenify('ACTIVE')


def _get_histories():
    histories = request('GET', 'exploit_history')
    exploits = request('GET', 'exploit')

    result = {}
    for history in histories:
        hist_exploits = [
            exploit for exploit in exploits
            if exploit['exploit_history_id'] == history['id']
        ]
        for exploit in hist_exploits:
            exploit['timestamp'] = dt_from_iso(exploit['timestamp'])
        hist_exploits.sort(key=lambda x: x['timestamp'])

        result[history['id']] = {
            'id': history['id'],
            'service': history['service'],
            'exploits': hist_exploits,
        }

    return result


@app.command('ls', help='List all exploits.')
def exploit_ls(
    history_ids: List[str] = typer.Argument(None, help='History ID(s).')
):
    history_ids = set(history_ids)

    histories = _get_histories()

    for history_id, history_info in histories.items():
        if history_ids and history_id not in history_ids:
            continue

        typer.echo(f'{history_id} ({history_info["service"]})')

        has_active = False
        exploits = history_info['exploits']
        if not exploits:
            typer.echo('    No uploaded exploits yet')
        else:
            for exploit in exploits:
                if exploit['active']:
                    has_active = True

                active = ACTIVE_STR if exploit['active'] else ''
                ts = dt_to_local_str(exploit['timestamp'])
                typer.echo(f'    {ts} {active:6} {exploit["author"]} {exploit["id"]}')

        if has_active:
            typer.echo('')
            _print_exploit_targets(history_info, indent=4)

        typer.echo('')



@app.command('activate', help='Activate an exploit.')
def exploit_activate(
    exploit_id: str = typer.Argument(..., help=
        'Exploit ID or history ID. '
        'If an exploit ID is specified, activates that exploit. '
        'If a history ID is specified, activates the most recent exploit in '
        'the history if none is already activated.')
):
    resp = request('PATCH', f'exploit/{exploit_id}', data={
        'active': True
    })

    if not resp.get('success', True) and resp.get('error', '') == 'Exploit does not exist':
        histories = _get_histories()

        history = histories.get(exploit_id)
        if history is None:
            typer.echo(f'{ERROR_STR}: unknown exploit or history "{exploit_id}"')
            raise typer.Exit(code=1)

        if not history['exploits']:
            typer.echo(f'{ERROR_STR}: no exploits in history "{exploit_id}"')
            raise typer.Exit(code=1)

        if any(exploit['active'] for exploit in history['exploits']):
            typer.echo(f'{WARN_STR}: an exploit is already active, doing nothing')
            return

        exploit_id = history['exploits'][-1]['id']
        typer.echo(f'Activate {exploit_id}')
        resp = request('PATCH', f'exploit/{exploit_id}', data={
            'active': True
        })

    check_response(resp)


@app.command('deactivate', help='Deactivate an exploit.')
def exploit_deactivate(
    exploit_id: str = typer.Argument(..., help=
        'Exploit ID or history ID. '
        'If an exploit ID is specified, deactivates that exploit. '
        'If a history ID is specified, deactivates all exploits in the history.')
):
    resp = request('PATCH', f'exploit/{exploit_id}', data={
        'active': False,
    })

    if not resp.get('success', True) and resp.get('error', '') == 'Exploit does not exist':
        histories = _get_histories()

        history = histories.get(exploit_id)
        if history is None:
            typer.echo(f'{ERROR_STR}: unknown exploit or history "{exploit_id}"')
            raise typer.Exit(code=1)

        for exploit in history['exploits']:
            if exploit['active']:
                exploit_id = exploit['id']
                typer.echo(f'Deactivate {exploit_id}')
                check_response(request('PATCH', f'exploit/{exploit_id}', data={
                    'active': False
                }))
    else:
        check_response(resp)


@app.command('switch', help=
    'Activate an exploit and deactivate all others in the history.')
def exploit_switch(
    exploit_id: str = typer.Argument(..., help='Exploit ID.')
):
    exploits = request('GET', 'exploit')

    history_id = None
    for exploit in exploits:
        if exploit['id'] == exploit_id:
            history_id = exploit['exploit_history_id']
            break
    if history_id is None:
        typer.echo(f'{ERROR_STR}: unknown exploit "{exploit_id}"')
        raise typer.Exit(code=1)

    already_active = False
    for exploit in exploits:
        if exploit['exploit_history_id'] != history_id:
            continue
        if exploit['active']:
            if exploit['id'] == exploit_id:
                already_active = True
                continue
            typer.echo(f'Deactivate {exploit["id"]}')
            exploit_deactivate(exploit['id'])

    if not already_active:
        typer.echo(f'Activate {exploit_id}')
        exploit_activate(exploit_id)


@app.command('create', help='Create an exploit history.')
def exploit_create(
    history_id: str = typer.Argument(..., help='History ID (the "friendly" exploit name).'),
    service: str = typer.Argument(..., help='The target service.')
):
    resp = request('POST', 'exploit_history', data={
        'history_id': history_id,
        'service': service,
    })

    if not resp.get('success', True) and resp.get('error', '') == 'Unknown service':
        typer.echo(f'ERROR: unknown service "{service}", available services:')
        service_ls()
        raise typer.Exit(code=1)

    check_response(resp)


@app.command('upload', help='Upload an exploit.')
def exploit_upload(
    history_id: str = typer.Argument(..., help='History ID (the "friendly" exploit name).'),
    author: str = typer.Argument(..., help='The author.'),
    context: str = typer.Argument(..., help=
        'Path to a directory or tarball containing the Docker context. '
        'The Dockerfile must be top-level. '
        'Supported tarball compression formats: xz, bzip2, gzip, identity (no compression).'),
    switch: bool = typer.Option(False, help='Switch to new exploit after uploading.'),
    switch_if_active: bool = typer.Option(True, help=
        'Switch to new exploit after uploading if its history already has an active exploit.')
):
    if os.path.isdir(context):
        with io.BytesIO() as bio:
            with tarfile.open(fileobj=bio, mode='w:gz') as tar:
                tar.add(context, arcname='')
            bio.seek(0)
            context_data = bio.read()
    else:
        with open(context, 'rb') as f:
            context_data = f.read()

    resp = request('POST', 'exploit', data={
        'history_id': history_id,
        'author': author,
        'context': base64.b64encode(context_data).decode(),
    })
    check_response(resp)

    exploit_id = resp['exploit_id']
    typer.echo(exploit_id)

    if switch:
        if switch_if_active:
            typer.echo(f'{WARN_STR}: --switch overriding --switch-if-active')
        exploit_switch(exploit_id)
    elif switch_if_active:
        histories = _get_histories()
        history = histories[history_id]
        if any(exploit['active'] for exploit in history['exploits']):
            exploit_switch(exploit_id)
        else:
            typer.echo(f'{NOTICE_STR}: no active exploit in history, did not activate new exploit')


@app.command('download', help='Download an exploit.')
def exploit_upload(
    exploit_id: str = typer.Argument(..., help='Exploit ID.'),
    path: str = typer.Argument(..., help='Output directory (will be created).'),
    overwrite: bool = typer.Option(False, '--overwrite', help=
        'Proceed even if the destination directory already exists.'),
    unsafe: bool = typer.Option(False, '--unsafe', help=
        'DANGEROUS: do not perform safety checks before extracting the downloaded archive.')
):
    resp = request('GET', f'exploit/{exploit_id}/download')
    check_response(resp)

    data = base64.b64decode(resp['data'])

    with io.BytesIO(data) as bio:
        with tarfile.open(fileobj=bio) as tar:
            if not unsafe:
                for info in tar:
                    if info.name.startswith('/'):
                        typer.echo(f'{ERROR_STR}: unsafe archive: absolute path detected')
                        raise typer.Exit(code=1)
                    elif '/../' in f'/{info.name}/':
                        typer.echo(f'{ERROR_STR}: unsafe archive: path traversal detected')
                        raise typer.Exit(code=1)
                    elif info.islnk() or info.issym():
                        typer.echo(f'{ERROR_STR}: unsafe archive: link detected')
                        raise typer.Exit(code=1)

            try:
                os.mkdir(path)
            except FileExistsError:
                if overwrite:
                    typer.echo(f'{WARN_STR}: directory "{path}" already exists (proceeding anyway)')
                else:
                    typer.echo(f'{ERROR_STR}: directory "{path}" already exists (use --overwrite to proceed anyway)')
                    raise typer.Exit(code=1)

            tar.extractall(path)


import player_cli.cmd_exploit_logs
import player_cli.cmd_exploit_runlocal
import player_cli.cmd_exploit_template
