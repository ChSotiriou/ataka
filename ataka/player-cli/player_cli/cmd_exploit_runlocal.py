import os
import time
import typer
import shutil
import signal
import functools
import subprocess
import multiprocessing

from typing import List
from player_cli.cmd_exploit import app
from player_cli.ctfconfig_wrapper import OWN_HOST, RUNLOCAL_TARGETS
from player_cli.util import (
    request, magentify, greenify, yellowfy, redify, blueify, ERROR_STR,
    parse_dockerfile_cmd, highlight_flags, dt_from_iso, dt_to_local_str
)


SUCCESS_STR = greenify("success")
TIMEOUT_STR = yellowfy("timeout")


def _exploit_job(target, exe, args, workdir, exploit_id, timeout):
    msg = SUCCESS_STR

    try:
        proc = subprocess.run(args,
            executable=os.path.abspath(exe),
            stdin=subprocess.DEVNULL,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            timeout=timeout,
            env={
                'TARGET_IP': target['ip'],
                'TARGET_EXTRA': target['extra'],
            },
            cwd=os.path.abspath(workdir),
            text=True)
        if proc.returncode != 0:
            msg = f'{redify("failed")}, exit status {proc.returncode}'
        stdout = proc.stdout
    except subprocess.TimeoutExpired as e:
        msg = TIMEOUT_STR
        stdout = e.stdout

    flags = []
    if stdout:
        flags = request('POST', 'flag/submit', data={
            'flags': stdout,
        })

    return {
        'target': target,
        'msg': msg,
        'stdout': stdout,
        'flags': flags,
    }


@app.command('runlocal', help='Run an exploit locally.')
def exploit_runlocal(
    path: str = typer.Argument(..., help=
        'Path to exploit executable, or to a directory containing a Dockerfile. '
        'In the latter case, will try to run the container command locally. '
        'The working directory will be the one where the Dockerfile is located.'),
    service: str = typer.Argument(..., help='The target service.'),
    exploit_id: str = typer.Argument(..., help=
        'A unique exploit ID to associate flags with.'),
    target_ips: List[str] = typer.Option(RUNLOCAL_TARGETS, '--target', '-T', help=
        'Target to attack (you can specify this option multiple times).'),
    no_target_ips: List[str] = typer.Option([], '-N', '--no-target', help=
        'Target to not attack (you can specify this option multiple times).'),
    all_targets: bool = typer.Option(False, '--all-targets', help=
        'Attack all targets (overrides --target).'),
    exclude_own: bool = typer.Option(True, help=
        'Exclude our own vulnbox from the attack targets.'),
    timeout: int = typer.Option(30, '--timeout', '-t', help=
        'Timeout for a single exploit execution, in seconds.'),
    jobs: int = typer.Option(0, '--jobs', '-j', help=
        'Number of parallel jobs (0 for CPU count).'),
    limit: int = typer.Option(100, '--limit', '-l', help=
        'Limit stdout printing to <limit> chars. '
        'Set to -1 if you want to see the whole output.'),
    count: int = typer.Option(0, '-c', '--count', help=
        'Number of attack rounds to perform (0 for infinite).')
):
    target_ips = set(target_ips)
    no_target_ips = set(no_target_ips)

    if os.path.isdir(path):
        try:
            with open(f'{path}/Dockerfile', 'r') as f:
                dockerfile = f.read()
        except FileNotFoundError:
            typer.echo(f'{ERROR_STR}: directory specified, but no Dockerfile found')
            raise typer.Exit(code=1)
        except IOError:
            typer.echo(f'{ERROR_STR}: error reading Dockerfile')
            raise typer.Exit(code=1)
        exe_args = parse_dockerfile_cmd(dockerfile)
        if exe_args is None:
            typer.echo(f'{ERROR_STR}: could not extract command from Dockerfile')
            raise typer.Exit(code=1)
        exe = shutil.which(exe_args[0])
        if exe is None:
            typer.echo(f'{ERROR_STR}: could not find executable for "{exe_args[0]}"')
            raise typer.Exit(code=1)
        workdir = path
    else:
        if not os.access(path, os.X_OK):
            typer.echo(f'{ERROR_STR}: exploit file is not executable')
            raise typer.Exit(code=1)
        exe = path
        exe_args = [path]
        workdir = '.'

    if jobs == 0:
        jobs = multiprocessing.cpu_count()

    config = request('GET', 'init')
    if config['ctf_config'] is None:
        typer.echo(f'{ERROR_STR}: no CTF config from backend')
        raise typer.Exit(code=1)
    ctf_config = config['ctf_config']

    services = ctf_config['services']
    if service not in services:
        typer.echo(
            f'{ERROR_STR}: unknown service "{service}". '
            f'Available services: {magentify(", ".join(services))}.')
        raise typer.Exit(code=1)

    original_sigint_handler = signal.signal(signal.SIGINT, signal.SIG_IGN)
    pool = multiprocessing.Pool(jobs)
    signal.signal(signal.SIGINT, original_sigint_handler)

    job_func = functools.partial(_exploit_job, exe=exe, args=exe_args,
        workdir=workdir, exploit_id=exploit_id, timeout=timeout)

    num_rounds = 0
    round_time = ctf_config['round_time']
    try:
        while True:
            typer.echo('[*] Attack round started')

            start = time.time()

            targets = request('GET', f'targets/service/{service}')
            if not all_targets:
                targets = [t for t in targets if t['ip'] in target_ips]
            if exclude_own:
                targets = [t for t in targets if t['ip'] != OWN_HOST]
            targets = [t for t in targets if t['ip'] not in no_target_ips]

            targets_summary = ', '.join(t['ip'] for t in targets)
            typer.echo(f'[*] Attacking {len(targets)} targets: {targets_summary}')

            for result in pool.imap_unordered(job_func, targets):
                host = result['target']['ip']
                extra = result['target']['extra']
                msg = result['msg']
                flags = result['flags']
                typer.echo(f'[*] Execution completed on target {host}: {msg}')
                typer.echo(f'    Extra: {extra}')
                typer.echo(f'    Submitted {len(flags)} flags:')
                for flag in flags:
                    dt = dt_to_local_str(dt_from_iso(flag["timestamp"]))
                    typer.echo(f'        {dt} | ID {flag["id"]}: {flag["flag"]} ({flag["status"]})')

                if limit == -1:
                    typer.echo(f'    Execution output:')
                    # Assumes author wants to see the stdout in a beautiful way, so no repr
                    typer.echo(highlight_flags(result['stdout'], blueify))
                elif result["stdout"] is not None:
                    typer.echo(f'    Execution output: {magentify(repr(result["stdout"][:limit]))}')

            num_rounds += 1
            if count > 0 and num_rounds == count:
                break

            end = time.time()
            if end - start < round_time:
                to_wait = int(round_time - (end - start))
                typer.echo(f'\n[*] Waiting {to_wait} seconds for next round')
                time.sleep(to_wait)
    except KeyboardInterrupt:
        typer.echo('[*] Terminating...')
        pool.terminate()
